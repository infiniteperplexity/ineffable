<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
</head>
<body onload="init()">
<style>
</style>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script>
$.urlParam = function(name){
	var results = new RegExp('[\\?&]' + name + '=([^&#]*)').exec(window.location.href);
	if (!results) {return 0;}
	return results[1] || 0;
}

var csv_data;
function init() {


var topMargin = 50, leftMargin = 150;

var width = 5000, height = 1000;
var svg = d3.select("body")
  .append("svg")
  	.attr("width",width)
  	.attr("height",height)
;
var nQuants = 4;
var cellHeight = 50;
var cellWidth = 50;
var nRows;
var nCols;
var columns;
var rows;

var csv_placeholder = [];
for(var i = 0; i<10; i++) {
	csv_placeholder.push({row: "row" + i});
	for (var j = 0; j<10; j++) {
		csv_placeholder[i]["variable" + j] = Math.random();
	}
}


var csv = $.urlParam("csv");
if (csv===0) {
	csv_data = csv_placeholder;
	callback(csv_data);
} else {
	d3.csv(csv+".csv", function(error, d) {
		csv_data = d;
		width = d3.map(csv_data[0]).keys().length*cellWidth+leftMargin;
		height = csv_data.length*cellHeight+topMargin;
		svg.attr("width",width).attr("height",height);
		callback(csv_data);
	})
}

function callback(data) {
	csv_data = data;
	columns = d3.map(csv_data[0]).keys();
	columns.shift();
	rows = csv_data.map(function(row) {return row["row"];})
	var flattened = [];
	for(var i = 0; i<rows.length; i++) {
		for(var j = 0; j<columns.length; j++) {
			flattened.push(csv_data[i][columns[j]]);
		}
	}

	var quantiles = [];
	for(var i = 0; i<=nQuants; i++) {
		quantiles.push(d3.quantile(flattened,i/nQuants));
	}
	var color = d3.scale.linear()
		.domain(quantiles)
		.range(["white","red"])
	;

	//should I check whether the two axes are the same to do a half graph?
	svg.selectAll("g")
		.attr("transform","translate("+leftMargin+","+topMargin+")")
		.data(csv_data).enter()
	  .append("g")
		.attr("transform", function(d,i) {return "translate(" + leftMargin + "," + (topMargin+i*cellHeight) + ")";})
	  .selectAll("rect")
	.data(function(row) {return columns.map(function(d) {return row[d];})}).enter()
	  .append("rect")
		.attr("x",function(d,i) {return i*cellWidth;})
		.attr("y",0)
		.attr("height",cellHeight)
		.attr("width",cellWidth)
		.style("fill",function(d) {return color(d);})
	;
	var x = d3.scale.ordinal()
		.domain(columns.concat(" "))
		.rangePoints([0,columns.length*cellWidth])

	;
	var y = d3.scale.ordinal()
		.domain(rows.concat(" "))
		.rangePoints([0,rows.length*cellHeight])
	;
	var xAxis = d3.svg.axis()
		.scale(x)
		.orient("top")
		.outerTickSize(cellWidth)
	;
	//secondary axes not yet implemented
	//var xAxis2 = d3.svg.axis()
	//	.scale(x)
	//	.orient("bottom")
	//	.outerTickSize(cellWidth)
	//;
	var yAxis = d3.svg.axis()
		.scale(y)
		.orient("left")
	;
	//secondary axes not yet implemented
	//var yAxis2 = d3.svg.axis()
	//	.scale(y)
	//	.orient("right")
	//;
	svg.append("g")
		.attr("class","axis")
		.call(xAxis)
		.style("fill","none")
		.style("stroke","black")
		.attr("transform","translate(" + leftMargin+","+topMargin+")")
	  .selectAll("text")
	  	.attr("transform","translate(" + 0.75*cellWidth + ",-10) rotate(-45)")
	  	.style("font-size","10px")

	;
	svg.append("g")
		.attr("class","axis")
		.call(yAxis)
		.style("fill","none")
		.style("stroke","black")
		.attr("transform","translate(" + leftMargin+","+topMargin+")")
	  .selectAll("text")
	  	.attr("transform","translate(0," + 0.5*cellHeight+")")
		.style("font-size","10px")
	;



}
callback(csv_data);

}
</script>
</body>
</html>
